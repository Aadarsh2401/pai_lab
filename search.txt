#input
def input_graph():
    graph={}
    
    n=int(input("Enter number of nodes"))
    for i in range(n):
        node=input("Enter node name")
        graph[node]=[]
        
    e=int(input("Enter number of edges"))
    for j in range(e):
        u=input("From: ")
        v=input("To: ")
        graph[u].append(v)
        graph[v].append(u)
        
        
    return graph



graph = input_graph()
print("Graph:",graph) 


#bfs search

from collections import deque

def bfs(graph, start, goal):
    queue = deque()
    queue.append([start])  # store path, not just node

    visited = set()
    nodes_expanded = 0

    while queue:
        path = queue.popleft()
        current = path[-1]

        if current == goal:
            return path, nodes_expanded

        if current not in visited:
            visited.add(current)
            nodes_expanded += 1

            for neighbor in graph[current]:
                new_path = list(path)
                new_path.append(neighbor)
                queue.append(new_path)

    return None, nodes_expanded


#dfs search 


def dfs(graph, current, goal, visited=None, nodes_expanded=0):
    if visited is None:
        visited = set()

    visited.add(current)
    nodes_expanded += 1

    if current == goal:
        return [current], nodes_expanded

    for neighbor in graph[current]:
        if neighbor not in visited:
            path, nodes_expanded = dfs(graph, neighbor, goal, visited, nodes_expanded)
            if path:
                return [current] + path, nodes_expanded

    return None, nodes_expanded


path, expanded = dfs(maze, start, goal)

print("Path found:", path)
print("Nodes expanded:", expanded)

import heapq

# Manhattan Distance Heuristic
def heuristic(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

# Get valid neighbors (Up, Down, Left, Right)
def get_neighbors(node, maze):
    rows = len(maze)
    cols = len(maze[0])
    x, y = node
    
    moves = [(-1,0), (1,0), (0,-1), (0,1)]
    neighbors = []
    
    for dx, dy in moves:
        nx, ny = x + dx, y + dy
        if 0 <= nx < rows and 0 <= ny < cols:
            if maze[nx][ny] == 0:  # not a wall
                neighbors.append((nx, ny))
    
    return neighbors

#Greeddy best first 
    def greedy_best_first_search(maze, start, goal):
    open_list = []
    heapq.heappush(open_list, (heuristic(start, goal), start))
    
    came_from = {}
    visited = set()
    nodes_expanded = 0

    while open_list:
        _, current = heapq.heappop(open_list)

        if current in visited:
            continue

        visited.add(current)
        nodes_expanded += 1

        if current == goal:
            break

        for neighbor in get_neighbors(current, maze):
            if neighbor not in visited:
                heapq.heappush(open_list, (heuristic(neighbor, goal), neighbor))
                came_from[neighbor] = current

    # Reconstruct Path
    path = []
    node = goal
    while node != start:
        path.append(node)
        node = came_from.get(node)
        if node is None:
            print("No Path Found")
            return
    path.append(start)
    path.reverse()

    print("Greedy Path:", path)
    print("Nodes Expanded:", nodes_expanded)

#a star search
    def a_star_search(maze, start, goal):
    open_list = []
    heapq.heappush(open_list, (0, start))
    
    came_from = {}
    g_cost = {start: 0}
    nodes_expanded = 0

    while open_list:
        _, current = heapq.heappop(open_list)
        nodes_expanded += 1

        if current == goal:
            break

        for neighbor in get_neighbors(current, maze):
            tentative_g = g_cost[current] + 1

            if neighbor not in g_cost or tentative_g < g_cost[neighbor]:
                g_cost[neighbor] = tentative_g
                f = tentative_g + heuristic(neighbor, goal)
                heapq.heappush(open_list, (f, neighbor))
                came_from[neighbor] = current

    # Reconstruct Path
    path = []
    node = goal
    while node != start:
        path.append(node)
        node = came_from.get(node)
        if node is None:
            print("No Path Found")
            return
    path.append(start)
    path.reverse()

    print("A* Path:", path)
    print("Nodes Expanded:", nodes_expanded)
